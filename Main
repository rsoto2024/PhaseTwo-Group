/*Rebeca Soto, Mathew L, Amanuel- Group 5
Phase Two, Part A */

.global _start

						
.data
	mem_number: .word 12
	div_result: .byte

						@user hardcodes two values into Register R4 and R5 in  
.text
_start:
	MOV R0, #0
	MOV R1, #0
	MOV R2, #0
	MOV R3, #0

	ADD R0, R4, R5			@R0 has the result of the addition
	MUL R1, R4, R5  		@R1 stores the result of multiplication				
	BVS Overflow_error		@checks if overflow occurred
	Overflow_error:
						@the product is larger than the registers can handle
	CMP R5, #0
	BEQ divisor_cantbe_zero
	divisor_cantbe_zero:
						@division by zero is an error
	
	MOV R0, #0
	MOV R2, R4
	B divlooptest
divloop:
	ADD R0, R0, #1			@increase counter / solution by 1
	SUB R2, R2, R5			@16-2
	
divlooptest:
	CMP R2, r5
	BGE divloop	

	LDR R1, =div_result		@load memory address into R1
	STR R0, [R1]			@Stores the quotient in the memmory location div_result


					@Using Bitwise operations AND, OR, XOR and shift operations
	MOV R8, #0x92 			@Move the binary digits of Ox92 into R8
	MOV R9, #0x80 			@Move the binary digits of Ox80 into R9
	EOR R10, R8, R9 		@Use XOR logic to isolate bits 2 and 5
	LSL R11, #3 			@Shift the 2nd bit to the most significant bit
	LSR R11, #4 			@Shift 4 digits to the right
	ORR R11, #0xF6 			@changes all 0 bits to 1
	AND R11, #0x55 			@changes the bit pattern to 

						@Addressing mode demonstrations
						@Register to Register, memory to register and vice versa
	MOV R12, R1			@moves the value in R1 to R12
	LDR R12, =mem_number		@loads memory address of mem_number to R12
	LDR R12, [R12]			@loads the value at the memory address to register 12
	STR R12, [R11]			@store the value from R12 at the memory address in R11

						@Stack operations
	SUB sp, sp, #4			@allocates space for the SP
	LDR R1, [sp]			@R1 is copied to that allocated memory and its address
	STR R1, [sp]  			@memory from the top is added back to R1 
	ADD sp, sp, #4 			@stack pointer moves by 4 bytes, deallocating memory
	PUSH {R7, R8}			@stores the registers on the stack
	POP {R7, R8}			@loads the previously allocated memory to the stack


	B end
end:
---------------------------------------------------------------------------------------------------------
.data
	lenstring: .string "count length"
	copystring: .string "copy string"
	copystring2: .space 0xFF
	compstring1: .string "compare"
	compstring2: .string "compare this"
	concatstring1: .string "this and"
	concatstring2: .string "that"
	concatstring3: .space 0xFF
.text
.global main
main:
str_length:
	MOV r0, #0 // set register that will store count to 0
	LDR r1, =lenstring // load r1 with string from memory
loop:
	LDRB r2, [r1, r3] // load byte of string from r1 with an offset of whatever value is in r3
	CMP r2, #0 // compare byte that is in r2 with 0 to check for null
	BEQ str_copy // if it is null, send immediatly to next part of program
	ADD r0, #1 // if it is not null add 1 to counter
	ADD r3, #1 // if it is not null, add 1 to offset
	B loop // branch back to beginning of loop
	
str_copy:
	MOV r3, #0 // set offset register to 0
	LDR r0, =copystring2 // load empty space into r0
	LDR r1, =copystring // load r1 with string from memory
loop2:
	LDRB r2, [r1, r3] // load byte from r1 to r2 with offset of r3
  STRB r2, [r0, r3] // store byte from r2 in r0 with offset of r3
	ADD r3, #1 // add 1 to offset
  CMP r2, #0x00 // compare r2 to null
  BNE loop2 // if not equal to null, loop again
	
str_compare:
	LDR r0, =compstring1 // load first string into r0
	LDR r1, =compstring2 // load second string into r1
	CMP r0, r1 // compare values of the two strings
	BGT greater // branch if greater
	BLT less // branch if less
	BEQ equal // branch if equal
equal:
	MOV r0, #0 // move 0 to r0 if equal
	B str_concat // next part of program
greater:
	MOV r0, #1 // move 1 to r0 if greater
	B str_concat // next part of program
less:
	MOV r0, #-1 // move -1 to r0 if less
	B str_concat // next part of program

str_concat:
	MOV r4, #0 // set offset register to 0
	LDR r0, =concatstring3 // load r0 with space
	LDR r1, =concatstring1 // load r2 with first string
	LDR r2, =concatstring3 // load r3 with second string
loop3:	
	LDRB r3, [r1, r4] // load byte from r1 to r3 with offset of r4
  STRB r3, [r0, r4] // store byte from r3 in r0 with offset of r4
	ADD r4, #1 // add 1 to offset
  CMP r3, #0x00 // compare r3 to null
  BNE loop3 // if not equal to null, loop again
loop4:
	LDRB r3, [r2, r4] // load byte from r1 to r3 with offset of r4
  STRB r3, [r0, r4] // store byte from r3 in r0 with offset of r4
	ADD r4, #1 // add 1 to offset
  CMP r3, #0x00 // compare r3 to null
  BNE loop4 // if not equal to null, loop again
-------------------------------------------------------------------------------------------------------------------------























-------------------------------------------------------------------------------------------------------------------------------------
/*Some of part C
Amanuel B, Mathew L, Rebeca S
*/.global main
.data 
myarray: .word 1,2,3,4,5
myarraysize: .word 5
.text 
@Input: R0 = array address, R1 =array size
@Output: R0 = min, R1 = max, R2 = sum
main:
LDR R0, =myarray		@Load base address of myarray
LDR R1, =myarraysize	
LDR R1, [R1]			@Array size 
MOV R2, #0				@Initialized to zero, loop counter
MOV R4, #0				@Sum in array_stats
MOV R5, #0				@temp current max
MOV R6, #0				@@temp min

PUSH {R0, R1}			@Preserve R0-R1

BL looptest
B end

loop:
LDR R3,[R0, R2, LSL #2] @Loop through array elements
ADD R2, R2, #1			@updates the loop counter
BL array_stats
B looptest

looptest:
CMP R2, R1
BGE end			@Branches when the loop has processed the array
B loop
@---------------------------------------------------------------------------------------------------
array_stats:
BL sum
BL max
BL set_min_a
BL min
CMP R2, R1
BEQ array_stats_values
B loop
@------------------------
sum:
//PUSH {R4}				@using R4 in this function so preserving 
ADD R4, R4, R3
BX LR
@-------------------------
max:
//PUSH {R5}
CMP R3, R5 				@Determine MAX
BGT found_max
BX LR
found_max:
MOV R5, R3				@Outputs the max value of the array
MOV PC, lr				@return to call min
@---------------------
min:
CMP R6, #0
BLE set_min_a
CMP R3, R6				@Compares the current array element with the current max 
BLE found_min
BX LR
set_min_a:	
CMP R2, #1
BEQ set_min_b
BX LR

				@sets the temp min value to the first array element
set_min_b:
MOV R6, R3
BX LR
		
found_min:
MOV R6, R3
BX LR

@-----------------------------
array_stats_values:
MOV R0,R6				@Holds the min value
MOV R2, R4				@holds Sum of array
MOV R1, R5				@holds the max value
POP {R0, R1}
@--------------------
	
	array_rotate:
MOV R2, #1				@rotation amount
MOV R3,	#0				@holds array values beginnig at first element to be shifted
MOV R4, #0				@holds array value of the element to the right of the need to shift value
MOV R5, #0				@points to the value R3, 1,2,3,4,5-increments by 1, starts at 0
MOV R6, #1				@points to the value in R4, 
MOV R7, #0				@Initialize the value to hold a value to be shifted 

B looptest2

loop2:					@loops through the array with different values saved in different holders
LDR R3, [R0, R5, LSL #2]@holds elements 1,3,5 after each loop, r5 is incremented
BL s_hold
BL store_toright
ADD R6, R6, #2			@increment R6(1) by 1, move to element 2,4, ?
ADD R5, R5, #2			@increment R5(0) by 1, move to element 1,3,5
B looptest2

looptest2:
CMP R6, R1
BGT end
B loop2

store_toright:
CMP R6, R1
BGE store_last
LDR R4,[R0,R6, LSL #2]	@loads the values to be replaced, holds them until R5 points to the correct position(2,4,6)
STR R3, [R0, R6, LSL #2]	@this array replaces index 0 to index 1(shifting right), index 1 was saved to register 4
BX LR
s_hold:	
CMP R5, #0					@If it is not the firsl element we want to branch 
BGT move_hold
BX LR
move_hold:					
STR R4, [R0, R5, LSL #2]	@places displaced value where the next value was just removed
BX LR

store_last:
MOV R6, #0
STR R3, [R0, R6, LSL #2]			@Store the last element in index 0
B end

end:
