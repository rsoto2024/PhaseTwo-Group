/*Rebeca Soto, Mathew L, Amanuel- Group 5
Phase Two, Part A */

.global _start

						
.data
	mem_number: .word 12
	div_result: .byte

						@user hardcodes two values into Register R4 and R5 in  
.text
_start:
	MOV R0, #0
	MOV R1, #0
	MOV R2, #0
	MOV R3, #0

	ADD R0, R4, R5			@R0 has the result of the addition
	MUL R1, R4, R5  		@R1 stores the result of multiplication				
	BVS Overflow_error		@checks if overflow occurred
	Overflow_error:
						@the product is larger than the registers can handle
	CMP R5, #0
	BEQ divisor_cantbe_zero
	divisor_cantbe_zero:
						@division by zero is an error
	
	MOV R0, #0
	MOV R2, R4
	B divlooptest
divloop:
	ADD R0, R0, #1			@increase counter / solution by 1
	SUB R2, R2, R5			@16-2
	
divlooptest:
	CMP R2, r5
	BGE divloop	

	LDR R1, =div_result		@load memory address into R1
	STR R0, [R1]			@Stores the quotient in the memmory location div_result


					@Using Bitwise operations AND, OR, XOR and shift operations
	MOV R8, #0x92 			@Move the binary digits of Ox92 into R8
	MOV R9, #0x80 			@Move the binary digits of Ox80 into R9
	EOR R10, R8, R9 		@Use XOR logic to isolate bits 2 and 5
	LSL R11, #3 			@Shift the 2nd bit to the most significant bit
	LSR R11, #4 			@Shift 4 digits to the right
	ORR R11, #0xF6 			@changes all 0 bits to 1
	AND R11, #0x55 			@changes the bit pattern to 

						@Addressing mode demonstrations
						@Register to Register, memory to register and vice versa
	MOV R12, R1			@moves the value in R1 to R12
	LDR R12, =mem_number		@loads memory address of mem_number to R12
	LDR R12, [R12]			@loads the value at the memory address to register 12
	STR R12, [R11]			@store the value from R12 at the memory address in R11

						@Stack operations
	SUB sp, sp, #4			@allocates space for the SP
	LDR R1, [sp]			@R1 is copied to that allocated memory and its address
	STR R1, [sp]  			@memory from the top is added back to R1 
	ADD sp, sp, #4 			@stack pointer moves by 4 bytes, deallocating memory
	PUSH {R7, R8}			@stores the registers on the stack
	POP {R7, R8}			@loads the previously allocated memory to the stack


	B end
end:
---------------------------------------------------------------------------------------------------------
.data
	lenstring: .string "count length"
	copystring: .string "copy string"
	copystring2: .space 0xFF
	compstring1: .string "compare"
	compstring2: .string "compare this"
	concatstring1: .string "this and"
	concatstring2: .string "that"
	concatstring3: .space 0xFF
.text
.global main
main:
str_length:
	MOV r0, #0 // set register that will store count to 0
	LDR r1, =lenstring // load r1 with string from memory
loop:
	LDRB r2, [r1, r3] // load byte of string from r1 with an offset of whatever value is in r3
	CMP r2, #0 // compare byte that is in r2 with 0 to check for null
	BEQ str_copy // if it is null, send immediatly to next part of program
	ADD r0, #1 // if it is not null add 1 to counter
	ADD r3, #1 // if it is not null, add 1 to offset
	B loop // branch back to beginning of loop
	
str_copy:
	MOV r3, #0 // set offset register to 0
	LDR r0, =copystring2 // load empty space into r0
	LDR r1, =copystring // load r1 with string from memory
loop2:
	LDRB r2, [r1, r3] // load byte from r1 to r2 with offset of r3
  STRB r2, [r0, r3] // store byte from r2 in r0 with offset of r3
	ADD r3, #1 // add 1 to offset
  CMP r2, #0x00 // compare r2 to null
  BNE loop2 // if not equal to null, loop again
	
str_compare:
	LDR r0, =compstring1 // load first string into r0
	LDR r1, =compstring2 // load second string into r1
	CMP r0, r1 // compare values of the two strings
	BGT greater // branch if greater
	BLT less // branch if less
	BEQ equal // branch if equal
equal:
	MOV r0, #0 // move 0 to r0 if equal
	B str_concat // next part of program
greater:
	MOV r0, #1 // move 1 to r0 if greater
	B str_concat // next part of program
less:
	MOV r0, #-1 // move -1 to r0 if less
	B str_concat // next part of program

str_concat:
	MOV r4, #0 // set offset register to 0
	LDR r0, =concatstring3 // load r0 with space
	LDR r1, =concatstring1 // load r2 with first string
	LDR r2, =concatstring3 // load r3 with second string
loop3:	
	LDRB r3, [r1, r4] // load byte from r1 to r3 with offset of r4
  STRB r3, [r0, r4] // store byte from r3 in r0 with offset of r4
	ADD r4, #1 // add 1 to offset
  CMP r3, #0x00 // compare r3 to null
  BNE loop3 // if not equal to null, loop again
loop4:
	LDRB r3, [r2, r4] // load byte from r1 to r3 with offset of r4
  STRB r3, [r0, r4] // store byte from r3 in r0 with offset of r4
	ADD r4, #1 // add 1 to offset
  CMP r3, #0x00 // compare r3 to null
  BNE loop4 // if not equal to null, loop again
